---
title: Sorting Algorithms
date: '2023-07-16'
tags: ['DSA', 'Sorting', 'Algorithms', 'Python']
draft: false
summary: Learn how sorting algorithm works and real world use case of it.
thumbnail: https://res.cloudinary.com/bignums/image/upload/v1689563017/sorting-algorithms_t7eh7r.webp
---

## **Sorting Algorithms**

1. **Bubble Sort**: This is one of the simplest sorting algorithms. It works by repeatedly swapping adjacent elements if they are in the wrong order. Here's how you can implement it in Python:

```python
def bubble_sort(arr):
    n = len(arr)

    for i in range(n):
        for j in range(0, n - i - 1):  # Last i elements are already sorted
            if arr[j] > arr[j + 1]:  # Swap if current element is greater than next
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print("Sorted array is:", arr)
```

**Example:**

Consider an unsorted array: `[29, 10, 14, 37, 13]`. Here's a visual representation of how Bubble Sort will sort this array:

```plaintext
[29, 10, 14, 37, 13]  -> Compare 29 and 10, swap because 29 > 10
[10, 29, 14, 37, 13]  -> Compare 29 and 14, swap because 29 > 14
[10, 14, 29, 37, 13]  -> Compare 29 and 37, no swap because 29 < 37
[10, 14, 29, 37, 13]  -> Compare 37 and 13, swap because 37 > 13
[10, 14, 29, 13, 37]  -> Now the largest number is at the end

// Start the next pass

[10, 14, 29, 13, 37]  -> Compare 10 and 14, no swap because 10 < 14
[10, 14, 29, 13, 37]  -> Compare 14 and 29, no swap because 14 < 29
[10, 14, 29, 13, 37]  -> Compare 29 and 13, swap because 29 > 13
[10, 14, 13, 29, 37]  -> Now the second largest number is at the second last position

// Continue this process until the whole array is sorted
```

Bubble Sort continues this process of checking pairs and swapping them if needed, which "bubbles up" the largest value to its correct position.

Bubble Sort has a worst-case and average time complexity of O(n²), where n is the number of items being sorted. While it is not efficient for large data sets, it's straightforward to understand and implement.

2. **Selection Sort**: This algorithm sorts an array by repeatedly finding the minimum element from the unsorted part of the array and swapping it with the first unsorted element. Here's the Python code for it:

```python
def selection_sort(arr):
    n = len(arr)
    
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j  # Find minimum element in remaining unsorted array
                
        arr[i], arr[min_idx] = arr[min_idx], arr[i]  # Swap the found minimum with the first element of unsorted array

arr = [64, 25, 12, 22, 11]
selection_sort(arr)
print("Sorted array is:", arr)
```

**Example:**

Consider the same unsorted array: `[29, 10, 14, 37, 13]`. Here's a visual representation of how Selection Sort will sort this array:

```plaintext
[29, 10, 14, 37, 13]  -> Find the minimum in the whole array, 10, and swap it with the first element
[10, 29, 14, 37, 13] 

// Start the next pass, don't consider the first element anymore

[10, 29, 14, 37, 13]  -> Find the minimum in the remaining array, 13, and swap it with the second element
[10, 13, 14, 37, 29]

// Continue this process until the whole array is sorted
```

Selection Sort continually selects the smallest element in the unsorted portion of the array and swaps it with the first unsorted element, thus extending the sorted portion of the array by one with each pass.

Selection Sort also has a time complexity of O(n²) in all cases, but it doesn't make more than O(n) swaps and can be useful when memory write is a costly operation.

3. **Quick Sort**: This is a highly efficient sorting algorithm and is based on the divide-and-conquer approach. It works by selecting an 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. Here's the Python code for it:

```python
def partition(arr, low, high):
    i = low - 1         # Index of smaller element
    pivot = arr[high]   # Pivot

    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]

    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1

def quick_sort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)  # Partitioning index, arr[p] is now at right place

        quick_sort(arr, low, pi-1)  # Separately sort elements before partition
        quick_sort(arr, pi+1, high)  # and after partition

arr = [10, 7, 8, 9, 1, 5]
n = len(arr)
quick_sort(arr, 0, n-1)
print("Sorted array is:", arr)
``` 
**Example:**

Consider the same unsorted array: `[29, 10, 14, 37, 13]`. Here's a visual representation of how Quick Sort will sort this array:

```plaintext
[29, 10, 14, 37, 13]  -> Select the last element as pivot, 13, partition the array: elements less than 13 to the left, 13, and elements greater than 13 to the right
[10, 13, 29, 14, 37]

// Apply quick sort for the two partitions separately

[10, 13, 29, 14, 37]  -> Left partition: only one element, already sorted
[10, 13, 29, 14, 37]  -> Right partition: select 37 as pivot, partition the array
[10, 13, 14, 29, 37]

// Now the whole array is sorted
```

Quick Sort works by selecting a 'pivot' and partitioning the array into two - one with elements smaller than the pivot and one with elements larger. It then recursively applies the same process to the partitions until the entire array is sorted.

The average and best-case time complexity of Quick Sort is O(n log n), but the worst case (when the input is already sorted) is O(n²). Despite this, Quick Sort is faster in practice than other O(n²) algorithms such as Bubble Sort and Selection Sort due to its in-place partitioning and good average-case behavior.



